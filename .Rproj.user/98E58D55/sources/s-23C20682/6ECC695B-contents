# loading packages and data --------------------------------------------------------
if (!require("librarian")) install.packages("librarian")

librarian::shelf(haven,
                 tidyverse,
                 ggpubr,
                 sjlabelled,
                 viridis,
                 svglite,
                 mgsub, #for multiple substitutions
                 car,
                 psych,
                 mediation,
                 hrbrthemes)

# v1 <- haven::read_sav("J9528 Out-School Survey - SPSS Data file (v1, 20211018).sav")

v15 <- haven::read_sav("J9528 In-School Survey - SPSS Data file (online & paper)(v15, 20211217) Together only.sav")

# obtain the label dataset from v15 -------------------------------------------------------
# vlabel of the attributes; can access using index, same index as the colnames from v15
vlabel <- v15 %>% map_chr( ~ attributes(.)$label)

# access using double square brackets
vlabel_list <- lapply(vlabel, "[")

vlabel_df <- cbind(names(vlabel), Reduce(x = vlabel_list, f = "rbind", accumulate = FALSE))

colnames(vlabel_df) <- c("var", "label")

# perceived std related scores --------------------------------------------
# the scores for stigma and shame happen to match correctly with 1, 2, 3 and 4
# calculated before adding back the labels
stigma <- c("D10_1#", "D10_2#", "D10_3#", "D10_4#", "D10_5#", "D10_6#", "D10_7#", "D10_8#", "D10_9#")
shame <- c("D11_1#", "D11_2#", "D11_3#", "D11_4#","D11_5#")

# p for perception
p_cal <- function(v15, questions_col) {
  relevant_q <- v15 %>% dplyr::select(all_of(questions_col))
  
  # so by default if there was any NA values would be NA as rowSums would return NA already
  score_vector <- rowSums(relevant_q)
  
  return(score_vector)
}

# relevant_q[1, 1] <- NA # for testing the NAs

v15$Stigma <- p_cal(v15, stigma)
v15$Shame <- p_cal(v15, shame)


# add back SPSS labels ----------------------------------------------------
v15 <- sjlabelled::as_label(v15)
# added back so easier to change to ordinal data in the next step



# some descriptive info ---------------------------------------------------
# v15 %>% filter(`A1#` != 19) %>% 
#   group_by(Gender) %>% 
#   summarise(N = n())

# table(v15$`A1#`)


# change variable name for device use; more intuitive variable names and also reduce to three categories -------------------------------------
# three copies of this rather than a closure; no better way to find key-value pairs so do so manually in the "case_when" part
h1x_five_to_three <- function(v15, colname, newname) {
  idx <- which(names(v15) == colname)
  col <- v15[, idx] %>% pull()
  
  new_col <-
    case_when(
      col == "Much less" ~ 1,
      col == "Less" ~ 1,
      col == "The same" ~ 2,
      col == "More" ~ 3,
      col == "Much more" ~ 3,
      TRUE ~ 0 # have to assign 0 not NA or else different character type
    )
  
  v15$new <- new_col
  v15$new[which(v15$new == 0)] <- NA
  names(v15)[which(names(v15) == "new")] <- newname
  
  return(v15)
}

h1x_colnames <- c("I1_1#", "I1_2#", "I1_3#", "I1_4#", "I1_5#")
h1x_newnames <- c("covid_attend_school", "covid_extra_c", "covid_rest", "covid_eating", "covid_leisure")

# a poorly written loop with copying, but data isn't too large so it's ok
for (i in seq(length(h1x_colnames))) {
  v15 <- h1x_five_to_three(v15, h1x_colnames[i], h1x_newnames[i])
}

h2x_first <- function(v15, colname, newname) {
  idx <- which(names(v15) == colname)
  col <- v15[, idx] %>% pull()
  
  new_col <-
    case_when(
      col == "Much poorer" ~ 1,
      col == "Poorer" ~ 1,
      col == "Unchange" ~ 2,
      col == "Better" ~ 3,
      col == "Much better" ~ 3,
      TRUE ~ 0 # have to assign 0 not NA or else different character type
    )
  
  v15$new <- new_col
  v15$new[which(v15$new == 0)] <- NA
  names(v15)[which(names(v15) == "new")] <- newname
  
  return(v15)
}

# v15$"I1_5#"

h2x_first_colnames <- c("I2_1#", "I2_2#", "I2_3#", "I2_4#", "I2_5#", "I2_6#", "I2_7#", "I2_8#") # I2_8 is on online learning even though not in the online learning questionnaire
h2x_first_newnames <- c("covid_body_health", "covid_mental_health", "covid_sleeping_q", "covid_rs_fam_tog", "covid_rs_fam_nt_tog", "covid_rs_friends", "covid_rs_mate", "covid_online_learn")

for (i in seq(length(h2x_first_colnames))) {
  v15 <- h2x_first(v15, h2x_first_colnames[i], h2x_first_newnames[i])
}

h2x_last <- function(v15, colname, newname) {
  idx <- which(names(v15) == colname)
  col <- v15[, idx] %>% pull()
  
  # note for factor analysis could change back from here
  
  new_col <-
    case_when(
      col == "Much less" ~ "Decreased",
      col == "Less" ~ "Decreased",
      col == "Unchanged" ~ "Unchanged", # this time unchanged, instead of unchange
      col == "More" ~ "Increased",
      col == "Much more" ~ "Increased",
      TRUE ~ "NA" # have to assign 0 not NA or else different character type
    )
  
  v15$new <- new_col
  v15$new[which(v15$new == 0)] <- NA
  names(v15)[which(names(v15) == "new")] <- newname
  
  return(v15)
}

h2x_last_colnames <- c("I2_9#", "I2_10#")
h2x_last_newnames <- c("covid_exercise_quantity", "covid_electronic_dev")

for (i in seq(length(h2x_last_colnames))) {
  v15 <-
    h2x_last(v15, h2x_last_colnames[i], h2x_last_newnames[i])
}

# newnames <- c("covid_attend_school", "covid_extra_c", "covid_work_rest", "covid_eating", "covid_leisure", "covid_body_health", "covid_mental_health", "covid_sleeping_q", "covid_rs_fam_tog", "covid_rs_fam_nt_tog", "covid_rs_friends", "covid_rs_mate", "covid_online_learn", "covid_exercise_quantity", "covid_electronic_dev")


# calculation of sexuality knowledge scores -------------------------------
# after adding back SPSS labels or else not know which is correct
# k for knowledge
k_cal <- function(v15, questions_col) {
  relevant_q <- v15 %>% 
    dplyr::select(all_of(questions_col))
  
  score_vector <- apply(relevant_q, MARGIN = 1, FUN = function(x) { length(which(x == "Correct"))})
  return(score_vector)
}

pregnancy <- c("D1_1#", "D1_2#", "D1_3#", "D1_4#")
sti <- c("D1_5#", "D1_6#", "D1_7#", "D1_8#")
aids <- c("D1_9#", "D1_10#", "D1_11#", "D1_12#")

v15$"Pregnancy Knowledge" <- k_cal(v15, pregnancy)
v15$"STI Knowledge" <- k_cal(v15, sti)
v15$"AIDS Knowledge" <- k_cal(v15, aids)


# arbitrary sex openness score --------------------------------------------
openness_cal <- function(v15, questions_col) {
  relevant_q <- v15 %>% 
    dplyr::select(all_of(questions_col))
  
  score_vector <- apply(relevant_q, MARGIN = 1, FUN = function(x) { length(which(x == "Accept"))})
  return(score_vector)
}
# although D5_21 and 22 should be gender specific, people still answered both; may want to filter by gender 
sex_openness <- grep(pattern = "^D5_[0-9]+#", x = names(v15), value = TRUE)

v15$Openness <- openness_cal(v15, sex_openness)


# calculate HPV knowledge scores ------------------------------------------
# merge the male and female scores
# same question of male and female version; function to collapse and change the factors from agree/disagree/no idea/NA to correct/incorrect
collapse_and_correct <- function(v15, q, correct_ans) {
  same_q <- v15 %>% 
    dplyr::select(all_of(q))
    
  # subset out the ones with NA
  na1 <- is.na(same_q[,1])
  na2 <- is.na(same_q[,2])
  
  # square brackets to turn into vector rather than df; find where same 
  # ones with NA in both positions; or with non-NA in both positions (ambiguously answered twice)
  idx <- which(na1[,1] == na2[,1])
  # No idea is an existing factor so easy to convert; change only second column so only one value remains after collapsing with is.na
  same_q[idx, 2] <- "No idea"
  
  # take the one is not NA
  collapsed_q <- same_q[!is.na(same_q)]
  cor_q <- ifelse(collapsed_q == correct_ans, "Correct", "Incorrect")
  return(cor_q)
}

q1 <- c("C3M_1#", "C3F_1#")
q2 <- c("C3M_2#", "C3F_2#")
q4 <- c("C3M_4#", "C3F_4#")

v15$C3_1 <- collapse_and_correct(v15, q1, "Agree")
v15$C3_2 <- collapse_and_correct(v15, q2, "Agree")
v15$C3_4 <- collapse_and_correct(v15, q4, "Disagree")

hpv <- c("C3_1", "C3_2","C3_4")

# collate the scores based on correct/incorrect with new columns
v15$"HPV Knowledge" <- k_cal(v15, hpv)

# add to get the overall sexual knowledge ---------------------------------
v15$"Sexual Knowledge" <- v15$"HPV Knowledge" + v15$"Pregnancy Knowledge" + v15$"STI Knowledge" + v15$"AIDS Knowledge"

# change factors level order ----------------------------------------------------
# v15$device_use <- as.factor(v15$device_use)
# 
# v15$device_use <- factor(v15$device_use, levels = c("less", "unchanged", "more"))

# factors to explore ------------------------------------------------------
social_media <- grep(pattern = "^F1_.*", x = names(v15), value = TRUE)
knowledge <- grep(pattern = "Knowledge", x = names(v15), value = TRUE)

# sex_openness <- grep(pattern = "^D5_[2-8]#", x = names(v15), value = TRUE)


# change the codes to names for acceptance bar stack plots ----------------
acceptance_codes <- c("D5_6#", "D5_7#", "D5_8#", "D5_9#", "D5_16#", "D5_17#", "D5_18#", "D5_19#") 
acceptance <- c("Male homosexuality", "Female homosexuality", "Bisexuality", "Transexuality", "Compensated dating without sex trade", "Compensated dating with sex trade", "Being a prostitute")

names(v15)[names(v15) %in% acceptance_codes] <- acceptance

factor <- acceptance
factor <- social_media
factor <- knowledge

stig <- c("Stigma", "Shame")
factor <- stig

# pivot -------------------------------------------------
v15p <- tidyr::pivot_longer(data = v15, 
                      cols = all_of(factor),
                      names_to = "factor",
                      values_to = "value")

v15p <-
  v15p %>% filter(covid_electronic_dev == "Decreased" |
                    covid_electronic_dev == "Increased")

# age filtering
names(v15p)[colnames(v15p) == "A1#"] <- "Age"

# convert to numeric such that could subset later
v15p$Age <- as.numeric(v15p$Age)


v15
vlabel_df
# the plots rely on the "covid_electronic_dev"
# names(v15p)[which(names(v15p) == "covid_electronic_dev")] <- "changes in electronic device use during COVID"

v15p
a

# this a to prevent accidental expansion of subsections below
# function to compute mean for variables of interest based on indicated factor groups --------

# split such that frequency can be calculated
split_df <- split(x = v15, f = v15$device_use)

# double insure
split_df["NA"] <- NULL

# df is each df inside the list
get_counts_by_factor <- function(name_df, split_df, col_names) {
  output <- vector("list", length(col_names))
  
  df <- split_df[[name_df]]

  for (idx in seq_along(col_names)) { # contains the column names of interest
    col <- which(names(df) == col_names[idx]) # col refers to index of df that matches
    freq_df <- as.data.frame(table(df[, col]))
    
    names(freq_df)[names(freq_df) == "Freq"] <- social_media[idx]
    
    output[[idx]] <- freq_df
    names(output)[idx] <- col_names[idx] # purposes of Reducing later; need to keep track of name
  }
  
  # at this point should have freq dataframes that of same length for the ease of simple plotting later
  output_df <- Reduce(x = output, f = "cbind", accumulate = FALSE)
  
  # remove the duplicate which is the "Var1"
  output_df <- output_df[, unique(names(output_df))]
  
  # names(output_df) <- as.character(unlist(output_df[1,]))
  # output_df <- output_df[-1, ]
  # 
  # output_df <- as.data.frame(t(output_df))
  
  output_df$fctr <- name_df
  return(output_df)
}

freq_df <- lapply(X = names(split_df), FUN = get_counts_by_factor, split_df, factor)

get_percent <- function(df) {
  fctr <- df$fctr
  df <- df[-which(names(df) == "fctr")]
  
  # robustness may be a problem if Var1 and/or fctr are also numeric
  num <- df[unlist(lapply(df, is.numeric))]
  df[unlist(lapply(df, is.numeric))] <- num/colSums(num)
  
  df <- cbind(df, fctr)
  return(df)
}

freq_df <- lapply(X = freq_df, FUN = get_percent)
# not yet calculated proportions as maybe graph could handle that

freq_df <- Reduce(x = freq_df, f = "rbind", accumulate = FALSE)



# pivot dataset -----------------------------------------------------------

y_var <- names(freq_df)[(names(freq_df) != "Var1" & names(freq_df) != "fctr")]
freq_df <- pivot_longer(data = freq_df, 
                        cols = all_of(y_var),
                        names_to = "factor",
                        values_to = "percentage")


# v15$"F1_13#" %>% sjlabelled::label_to_colnames()
# 
# sjlabelled::get_label(v15$"F1_13#")
# sjlabelled::get_labels(v15$"F1_13#")
# 
# sjlabelled::as_label(v15$"F1_1#")
# 
# 
# # order matters in tapply
# tapply(X = v15df$"F1_1#",
#        INDEX = v15df$device_use,
#        FUN = mean)
# 
# v15df %>% sjlabelled::label_to_colnames()
# 
# social_media_cols <- which(names(v15) %in% social_media)
# 
# v15df[, social_media_cols] <- apply(v15df[, social_media_cols], MARGIN = 2, FUN = as.numeric)
# 
